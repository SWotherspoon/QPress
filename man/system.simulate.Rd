% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Community.R
\name{system.simulate}
\alias{system.simulate}
\title{Simulate System}
\usage{
system.simulate(n.sims, edges, required.groups = c(0),
  sampler = community.sampler(edges, required.groups), validators = NULL)
}
\arguments{
\item{n.sims}{number of matrices to simulate.}

\item{edges}{an edge list.}

\item{required.groups}{a vector of integers specifying which
groups of edges must always occur in the community matrix.}

\item{sampler}{the sampler object used to generate random weights
(see \code{\link{community.sampler}})}

\item{validators}{an (optional) list of validation functions
generated by \code{press.validate}.}
}
\value{
Returns a list with elements
\item{\code{edges}}{The edge list}
\item{\code{A}}{A list of inverse community matrices}
\item{\code{w}}{A matrix of the corresponding edge weights}
\item{\code{total}}{The total number of matrices generated}
\item{\code{stable}}{The number of stable matrices generated}
\item{\code{accepted}}{The number of matrices accepted for the sample}
}
\description{
Simulate Inverse Community Matrices for a Network
}
\details{
Generate sets of edge weights and the inverse community matrices
given a directed graph and validation criteria by rejection
sampling.  Matrices with a pattern of signs consistent with the
given model are generated, and only the matrices that correspond
to stable equilibria and consistent with the given validation
criteria are retained.  For matrices retained in the sample, the
matrix is inverted, and the \emph{inverse} community matrix, and
the weights that define the community matrix are returned. The
function also returns the total number of matrices generated, the
number of these that are stable and the number that are ultimately
accepted for the sample.

The output of this function may be passed to the interactive
exploratory tools.

This function is a simple wrapper for \code{community.sampler},
\code{stable.community} and the functions generated by
\code{press.validate}.
}
\examples{
set.seed(32)
## Sample model
edges <- parse.text(c(
  "E *-> D",
  "D *-> C",
  "C -> E",
  "E *-> B",
  "B *-> A",
  "A -> E",
  "D --> B"))
edges <- enforce.limitation(edges)
sims <- system.simulate(10,edges,
                        validators=list(
                          press.validate(edges,
                                         perturb=c(D=1),
                                         monitor=c(D=1)),
                          press.validate(edges,
                                         perturb=c(D=1),
                                         monitor=c(B=-1,C=1))))
}

