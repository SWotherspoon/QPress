% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Community.R
\name{system.simulate0}
\alias{system.simulate0}
\title{Simulate System}
\usage{
system.simulate0(n.sims, edges, required.groups = c(0),
  sampler = community.sampler(edges, required.groups), validators = NULL)
}
\arguments{
\item{n.sims}{number of matrices to simulate.}

\item{edges}{an edge list.}

\item{required.groups}{a vector of integers specifying which
groups of edges must always occur in the community matrix.}

\item{sampler}{the sampler object used to generate random weights
(see \code{\link{community.sampler}})}

\item{validators}{an (optional) list of validation functions
generated by \code{press.validate}.}
}
\value{
Returns a list with elements
\item{\code{edges}}{The edge list}
\item{\code{W}}{A list of community matrices}
\item{\code{w}}{A matrix of the corresponding edge weights}
\item{\code{total}}{The total number of matrices generated}
\item{\code{stable}}{Logical vector indicating which  matrices are stable}
\item{\code{accepted}}{Logical vector indicating which matrices meet the validation criteria}
}
\description{
Simulate Community Matrices for a Network
}
\details{
This function is an alternate form of \code{system.simulate}.

Generate sets of edge weights and community matrices given a
directed graph and validation criteria by rejection sampling.
Matrices with a pattern of signs consistent with the given model
are generated, and only the matrices that are consistent with the
given validation criteria are retained.  Each matrix is tested for
stability and the community matrix, the weights that define the
community matrix and its stability are returned. The function also
returns the total number of matrices generated and the number that
are ultimately accepted for the sample.

This function is a simple wrapper for \code{community.sampler},
\code{stable.community} and the functions generated by
\code{press.validate}.
}
\examples{
set.seed(32)
## Sample model
edges <- parse.digraph(c(
  "E *-> D",
  "D *-> C",
  "C -> E",
  "E *-> B",
  "B *-> A",
  "A -> E",
  "D --> B"))
edges <- enforce.limitation(edges)
sims <- system.simulate0(10,edges,
                         validators=list(
                           press.validate(edges,
                                          perturb=c(D=1),
                                          monitor=c(D=1)),
                           press.validate(edges,
                                          perturb=c(D=1),
                                          monitor=c(B=-1,C=1))))
}
